# Task
Understand how memory management works in Java, we will create a class which performs a task, and to make sure how our garbage collerctor works on the code.
# Our FlowChart
<img width="295" height="1100" alt="image" src="https://github.com/user-attachments/assets/ce9e2e90-a438-44b7-aa9f-88253fc25f34" />

# My Stack vs Heap
<img width="755" height="1026" alt="image" src="https://github.com/user-attachments/assets/1dab1ba7-60ff-4eac-b0df-5af53f79f1b6" />

# What were my challenges? 
What is the main difference between stack and heap? What is the difference between this and c++ and other virtual coading machines?
# Video Link
https://www.youtube.com/watch?v=M4TbW4LD1Tw

# My Code
```java
// class that is on the heap when creating an object
class Book {
private String title;
private int pages;

//constructor
public Book(String title, int pages) {
this.title = title;
this.pages = pages;
}

// method
public void displayInfo() {
System.out.println("Book: " + title + " (" + pages + " pages)");
}

// this method runs when gc destroys object
@Override
protected void finalize() throws Throwable {
System.out.println("Book object \"" + title + "\" is being garbage collected.");
super.finalize();
}
}

public class MemoryDemo {
public static void main(String[] args) {
// step 1, stack is b1 being our reference variable, and the heap is the rest, meaning b1 points to this object
Book b1 = new Book("Intro to Flying", 200);

//step 2 b2 again is our stack with b2 pointing to the object
Book b2 = new Book("Advanced Maneuvers", 350);

// step 3, java follows the references to access the objects on the heap
b1.displayInfo();
b2.displayInfo();

// step 4, b1 no longer would point anywhere and now the heap is unreachable for this specific object
b1 = null;

// step 5, requests garbage collections and the jvm may reclaim memory, if it does the finalize method now runs before the object is destroyed
System.gc();

System.out.println("End of program.");
}
}
```
